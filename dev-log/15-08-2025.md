# Complete Debugging Techniques Guide

## Table of Contents
- [HTTP Response Status Codes](#http-response-status-codes)
- [Breakpoint Debugging Techniques](#breakpoint-debugging-techniques)
- [Logging Configuration](#logging-configuration)
- [Advanced Logging Setup](#advanced-logging-setup)

---

## HTTP Response Status Codes

Understanding HTTP status codes is crucial for debugging web applications. Here are the most common ones you'll encounter:

### üü¢ 200 OK
**Meaning:** The request succeeded successfully.
- The server processed the request and returned the expected response
- Most common status code for successful operations
- Used for successful GET, POST, PUT requests

### üîÑ 302 Found (Temporary Redirect)
**Meaning:** The requested resource has been temporarily moved to a different URI.

**Key Points:**
- The client should continue using the original URI for future requests
- The server includes a `Location` header with the temporary URL
- Commonly used in web applications for navigation flow control

**Example Use Case:**
```
1. Browser sends DELETE request to remove data from database
2. Server processes the deletion successfully
3. Server responds with 302 redirect to display updated content
4. Browser automatically follows redirect to show refreshed page
```

### ‚ùå 404 Not Found
**Meaning:** The requested resource could not be found on the server.

**Common Causes:**
- Incorrect URL or typo in the request
- Resource has been moved or deleted
- Server routing configuration issues
- Case sensitivity problems in file paths

### üö® 500 Internal Server Error
**Meaning:** Something went wrong on the server side.

**Debugging Steps:**
1. Check server logs for detailed error messages
2. Review recent code changes
3. Verify database connections
4. Check server configuration files
5. Monitor server resources (memory, disk space)

---

## Breakpoint Debugging Techniques

### Server-side Breakpoint Debugging
- **IDE Integration:** Use your IDE's built-in debugger (IntelliJ IDEA, Eclipse, VS Code)
- **Remote Debugging:** Connect to running applications on remote servers
- **Conditional Breakpoints:** Set breakpoints that trigger only when specific conditions are met
- **Watch Variables:** Monitor variable values during execution
- **Step Through Code:** Execute code line by line to understand flow

### Client-side Breakpoint Debugging
- **Browser DevTools:** Use Chrome/Firefox Developer Tools
- **JavaScript Debugger:** Set breakpoints in browser or IDE
- **Network Tab:** Monitor API calls and responses
- **Console Debugging:** Use `console.log()` and `debugger` statements
- **React/Vue DevTools:** Specialized tools for frontend frameworks

---

## Logging Configuration

Logging is essential for understanding application behavior and troubleshooting issues in production environments.

### Understanding Log Levels

Logback provides five standard logging levels, from lowest to highest severity:

```java
package org.slf4j;
public interface Logger {
    // Printing methods in order of severity:
    public void trace(String message);  // Most detailed, typically disabled in production
    public void debug(String message);  // Detailed diagnostic information
    public void info(String message);   // General informational messages
    public void warn(String message);   // Warning messages for potentially harmful situations
    public void error(String message);  // Error events that might allow application to continue
}
```

**Log Level Hierarchy:**
- If you set the log level to `INFO`, only `INFO`, `WARN`, and `ERROR` messages will be displayed
- `TRACE` and `DEBUG` messages will be filtered out
- This helps control the verbosity of logs in different environments

### Basic Logging Configuration

#### Step 1: Configure application.properties

For simple logging to a file, add these properties to your `application.properties`:

```properties
# Output logs to a specific file
logging.file.name=/Users/haoshe/Desktop/workspace/data/community.log

# Set root log level (default for all loggers)
logging.level.root=INFO

# Set different log levels for different packages
logging.level.com.yourcompany.yourapp=DEBUG
logging.level.org.springframework=INFO
logging.level.org.hibernate=WARN

# Optional: Configure log file rolling
logging.file.max-size=10MB
logging.file.max-history=30

# Optional: Set console log pattern for better readability
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
```

#### Step 2: Expected Console Output

When you run your application with these settings, you'll see output similar to this in your console:

```
2024-08-16 10:30:15.123 [main] INFO  c.yourcompany.yourapp.Application - Starting Application
2024-08-16 10:30:15.456 [main] DEBUG c.yourcompany.yourapp.service.UserService - Loading user configuration
2024-08-16 10:30:15.789 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized on port 8080
2024-08-16 10:30:16.012 [main] WARN  o.hibernate.cfg.Configuration - Using deprecated configuration property
2024-08-16 10:30:16.345 [main] INFO  c.yourcompany.yourapp.Application - Application started successfully
```

**Key Points About This Output:**
- **Timestamp**: Shows exact time when each log was generated
- **Thread**: Indicates which thread generated the log (useful for multi-threaded applications)
- **Log Level**: Shows the severity level (DEBUG, INFO, WARN, ERROR)
- **Logger Name**: Abbreviated package and class name that generated the log
- **Message**: The actual log message

#### Step 3: Understanding What Gets Logged

Based on your configuration:

| Package | Configured Level | What Gets Logged |
|---------|------------------|------------------|
| `com.yourcompany.yourapp` | DEBUG | All messages: DEBUG, INFO, WARN, ERROR |
| `org.springframework` | INFO | INFO, WARN, ERROR (DEBUG filtered out) |
| `org.hibernate` | WARN | Only WARN and ERROR (DEBUG, INFO filtered out) |
| All other packages | INFO (root level) | INFO, WARN, ERROR |

#### Step 4: File Output Location

Your logs will be simultaneously written to:
- **Console**: Visible during application startup and runtime
- **File**: `/Users/haoshe/Desktop/workspace/data/community.log`

The file will contain the same log messages as shown in the console, making it easy to review application behavior after the fact.

---

## Advanced Logging Setup

For production applications, you'll want more sophisticated logging configuration. The `logback-spring.xml` file provides advanced features like log rotation, different output formats, and separate files for different log levels.

### Complete Logback Configuration

Create `src/main/resources/logback-spring.xml`:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- Application context name for identification -->
    <contextName>community</contextName>

    <!-- Define reusable properties -->
    <property name="LOG_PATH" value="/Users/haoshe/Desktop/workspace/data"/>
    <property name="APPDIR" value="community"/>
    <property name="LOG_PATTERN" value="%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"/>

    <!-- ========================
         CONSOLE APPENDER
         ======================== -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>utf-8</charset>
        </encoder>
    </appender>

    <!-- ========================
         ERROR LOG APPENDER
         ========================
         This appender writes ERROR-level logs to a rolling file.
         Old log files are archived by date and size.
    -->
    <appender name="FILE_ERROR" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!-- Specify the path and name of the active log file for ERROR logs -->
        <file>${LOG_PATH}/${APPDIR}/log_error.log</file>

        <!-- Define the rolling policy for log file rotation -->
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!-- Pattern for archived log files, including date and index for size-based splitting -->
            <fileNamePattern>${LOG_PATH}/${APPDIR}/error/log-error-%d{yyyy-MM-dd}.%i.log</fileNamePattern>

            <!-- Configure time-based and size-based file rotation -->
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>5MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>

            <!-- Keep 30 days of archived logs -->
            <maxHistory>30</maxHistory>
        </rollingPolicy>

        <append>true</append>

        <!-- Define log message format -->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d %level [%thread] %logger{10} [%file:%line] %msg%n</pattern>
            <charset>utf-8</charset>
        </encoder>

        <!-- Filter to only accept ERROR level messages -->
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>error</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- ========================
         INFO LOG APPENDER
         ======================== -->
    <appender name="FILE_INFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APPDIR}/log_info.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APPDIR}/info/log-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
        <append>true</append>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>utf-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>info</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- ========================
         DEBUG LOG APPENDER
         ======================== -->
    <appender name="FILE_DEBUG" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>${LOG_PATH}/${APPDIR}/log_debug.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/${APPDIR}/debug/log-debug-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>10MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
            <maxHistory>7</maxHistory> <!-- Keep debug logs for shorter period -->
        </rollingPolicy>
        <append>true</append>
        <encoder>
            <pattern>${LOG_PATTERN}</pattern>
            <charset>utf-8</charset>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.LevelFilter">
            <level>debug</level>
            <onMatch>ACCEPT</onMatch>
            <onMismatch>DENY</onMismatch>
        </filter>
    </appender>

    <!-- ========================
         LOGGER CONFIGURATIONS
         ======================== -->

    <!-- Root logger configuration -->
    <root level="INFO">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_ERROR"/>
        <appender-ref ref="FILE_INFO"/>
    </root>

    <!-- Application-specific logger -->
    <logger name="com.yourcompany.community" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE_ERROR"/>
        <appender-ref ref="FILE_INFO"/>
        <appender-ref ref="FILE_DEBUG"/>
    </logger>

    <!-- Third-party library loggers -->
    <logger name="org.springframework" level="WARN"/>
    <logger name="org.hibernate" level="WARN"/>
</configuration>
```

### Benefits of This Configuration

1. **Organized Log Files:** Separate files for different log levels make it easier to focus on specific types of issues
2. **Log Rotation:** Prevents log files from growing too large and consuming disk space
3. **Configurable Retention:** Automatically removes old log files based on your retention policy
4. **Performance:** Filtering at the appender level is more efficient than logging everything and filtering later
5. **Development vs Production:** Easy to adjust log levels for different environments

### Log File Structure

With this configuration, your logs will be organized as follows:
```
/Users/haoshe/Desktop/workspace/data/community/
‚îú‚îÄ‚îÄ log_error.log          # Current error logs
‚îú‚îÄ‚îÄ log_info.log           # Current info logs  
‚îú‚îÄ‚îÄ log_debug.log          # Current debug logs
‚îú‚îÄ‚îÄ error/                 # Archived error logs
‚îÇ   ‚îú‚îÄ‚îÄ log-error-2024-01-15.1.log
‚îÇ   ‚îî‚îÄ‚îÄ log-error-2024-01-16.1.log
‚îú‚îÄ‚îÄ info/                  # Archived info logs
‚îî‚îÄ‚îÄ debug/                 # Archived debug logs
```

### Best Practices

- **Use appropriate log levels:** Don't log everything at ERROR level
- **Include contextual information:** User IDs, request IDs, timestamps
- **Avoid logging sensitive data:** Passwords, credit card numbers, personal information
- **Use structured logging:** Consider JSON format for better parsing and analysis
- **Monitor disk space:** Ensure log rotation is working properly
- **Regular log analysis:** Use tools like ELK stack (Elasticsearch, Logstash, Kibana) for log analysis

---

## Additional Resources

- [Logback Manual](https://logback.qos.ch/manual/architecture.html) - Official documentation
- [Spring Boot Logging Reference](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging)
- [HTTP Status Code Reference](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)